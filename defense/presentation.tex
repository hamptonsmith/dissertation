\documentclass{beamer}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{MnSymbol}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{booktabs}

\DeclareMathAlphabet\mathbb{U}{msb}{m}{n}


\usetheme{Madrid}
\usecolortheme{beaver}
\title[Engineering Specifications and Mathematics]{Engineering Specifications and Mathematics\\for Verified Software}
\author{Hampton Smith}
\institute{Clemson University}
\date{May 16th, 2013}

\lstset{
	escapeinside={[*}{*]},
	basicstyle=\tiny
}

\lstdefinelanguage{Coq}
	{
		morekeywords={Definition,forall,let,Prop,Function,measure,if,then,else,end,match,with,unfold,intro,elim,reflexivity,replace,simpl,intros,split,change,rewrite,omega,assumption,symmetry,apply,auto,Qed,Theorem,functional,induction,in},
		sensitive=true,
		morecomment=[l]{--},
	}

\lstdefinelanguage{resolve}
	{
		morekeywords={restores,of,If,Recursive,Implicit,Powerset,Instance_Of,Theory,Precis,Categorical,introduces,related,Goal,Given,Definition,Facility,is,realized,by,Var,Concept,uses,Defines,Constraints,Initialization,Type,Family,exemplar,initialization,finalization,ensures,Operation,updates,requires,preserves,clears,evaluates,type,Extension,for,end,if,then,replaces,Procedure,convention,correspondence,iff,extended,Enhancement,Realization,represented,alters,in,modeled,constraint,While,changing,maintaining,decreasing,do,Theorem,For,all,implies,where,and,Precis,Subsumption},
		sensitive=true,
		morecomment=[l]{--},
		morecomment=[s]{(*}{*)},
		morestring=[b]",
	}
\lstset{language=resolve}


\begin{document}


\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Layout}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


\begin{frame}
\titlepage
\end{frame}

\section{Introduction}
\begin{frame}{What is verified software?}
	\begin{itemize}
		\item Mathematically prove properties of a program
		\begin{itemize}
			\item No null dereferences
			\item No buffer overflows
			\item No deadlock
			\item Termination
			\item Full behavior
		\end{itemize}
		\item Requires formal semantics
		\item Description of the desired behavior in a formal language
		\item Can be demonstrated by hand or mechanically
	\end{itemize}
\end{frame}


\begin{frame}{How do we verify?}
	\includegraphics[width=\textwidth]{verification_pipeline}
\end{frame}


\subsection{Example Systems}
\begin{frame}{Example Systems}
	\begin{columns}
	\begin{column}[l]{5cm}
		Practical Systems
		\begin{itemize}
			\item Existing industrial languages (C, Java)
			\item Limited mathematical language
			\item Focus on verifying narrow properties
			\item Automatic proofs
		\end{itemize}
	\end{column}
	\begin{column}[r]{5cm}
		Pure Systems
		\begin{itemize}
			\item Research or pure mathematical language
			\item Rich mathematical language
			\item Full verification (up to termination)
			\item Interactive proofs
		\end{itemize}
	\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Practical: Jahob}
	\begin{itemize}
		\item Implementation in a subset of Java
		\begin{itemize}
			\item No generics
			\item No dynamic dispatch
		\end{itemize}
		\item Specification in Isabelle
		\item Targets multiple back-end provers using intermediate first-order VC language
		\begin{itemize}
			\item CVC3
			\item Z3
		\end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}
	\lstinputlisting[basicstyle=\tiny,language=Java]{ArrayList1.java}
\end{frame}


\begin{frame}{The Good and the Bad}
	\begin{itemize}
		\item Used to verify suite of linked data structures
		\item How does Jahob do it?
		\begin{itemize}
			\item Flexible, integrated specification tools
			\begin{itemize}
				\item Pre-/Post-conditions
				\item Auxiliary variables
				\item Concept definitions
			\end{itemize}
			\item Encourages first-order specs to target multiple provers
			\item Permits in-line hints
		\end{itemize}
		\item But, there are some problems...
		\begin{itemize}
			\item Complex proof obligations
			\item Lack of mathematical modularity
		\end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}{Complex Proof Obligations}
	\begin{itemize}
		\item Must capture full Java complexity
		\begin{itemize}
			\item Null references
			\item Object aliasing
		\end{itemize}
		\item In-line assertions raise additional obligations
		\item Encourages cumbersome mathematical model
		\begin{itemize}
			\item Set of (index, element)
			\item Verify that no index appears twice
		\end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}{Lack of Mathematical Modularity}
	\begin{itemize}
		\item Higher-order mathematics hamstrung
		\begin{itemize}
			\item Encouraged to use a subset of Isabelle's power
			\item Lack of generics/dynamic dispatch limit usefulness
			\begin{itemize}
				\item No way to parameterize a spec
				\item No way to pass a definition
			\end{itemize}
		\end{itemize}
		\item Coupling of specifications
	\end{itemize}
\end{frame}


\begin{frame}{Pure: Coq}
	\begin{itemize}
		\item Pure mathematical language based on the calculus of inductive constructions
		\item Provides its own functional implementation language
		\begin{itemize}
			\item OCaml
			\item Haskell
			\item Scheme
		\end{itemize}
		\item Emphasizes interactive proving
	\end{itemize}
\end{frame}


\begin{frame}
	\lstinputlisting[basicstyle=\scriptsize,language=Coq]{DivPred.coq}
	\lstinputlisting[basicstyle=\scriptsize,language=Coq]{DivImpl.coq}
	\lstinputlisting[basicstyle=\scriptsize,language=Coq]{DivTheorem.coq}
\end{frame}


\begin{frame}
	\lstinputlisting[basicstyle=\scriptsize,language=Coq]{DivProof.coq}
\end{frame}

\begin{frame}{The Good and the Bad}
	\begin{itemize}
		\item Been used to verify a C compiler
		\item How does Coq do it?
		\begin{itemize}
			\item Rich, extensible mathematical language
			\begin{itemize}
				\item Hierarchy of types
				\item Higher-order logic
				\item User-defined theories
			\end{itemize}
			\item Programming model is functional
			\item Exploits human intuitions
		\end{itemize}
		\item But, there are some problems...
		\begin{itemize}
			\item Poorly integrated with the programming realm
			\begin{itemize}
				\item Verify cases that can't happen!
			\end{itemize}
			\item Automated prover is more flexible, but slower
			\item No notion of programming components
			\begin{itemize}
				\item Next compiler must be verified from scratch
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}{Best of Both Worlds?}
	\begin{itemize}
		\item Practical Systems
		\begin{itemize}
			\item Flexible, integrated specification
			\item Component support
		\end{itemize}
		\item Pure Systems
		\begin{itemize}
			\item Protection from certain complications (preferably still with the flexibility to use them)
			\item Rich, extensible mathematical language
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection{Problem/Thesis Statement}
\begin{frame}{Problem Statement}
	\begin{itemize}
		\item Architecture and implementation of a minimalist rewrite prover to explore those prover capabilities practically necessary to mechanically verify well-engineered, modular components.
		\item Design and implementation of an extensible, flexible supporting mathematical framework for a practical verification system that permits reuse as well as the development of a rich set of models and assertions.
		\item Design and implementation of a well-integrated specification framework that is explicitely designed to work with the mathematical system, supporting verifiability by allowing simple, flexible specifications and supporting scalability by encouraging verified component reuse.
		\item Validation of our central hypothesis via application of the minimalist prover to software constructed using the mathematical and specification framework.
	\end{itemize}
\end{frame}

\begin{frame}{Dissertation Goal}
	In a verification system, an extensible, flexible mathematics and specification subsystem enables better-engineered component specifications and thus more straightforward proof obligations that are easily dispatched by even minimalistic automated provers.  Design, development, and experimentation with such a verification system is the goal of this dissertation.
\end{frame}


\input{prover}
\input{math}


\section{Conclusion}
\begin{frame}{Conclusion}
	\begin{itemize}
		\item Systems need not be limited to the features of a pure or a practical system. Our hybrid system incorporates features of practical verification systems (static checking, efficient implementation, polymorphism) with pure mathematical systems (dependent types, higher-order logic, mathematical reusability.)
		\item Novel mechanism for static reasoning can be used to bridge the gap between undecidable, but flexible type systems and constrained, hierarchical systems.
		\item It can be demostrated empirically that using such a language, a programmer is capable of creating components about which reasoning is sufficiently easy that VCs can be dispatched by a minimalist prover.
		\item This includes a verified generic sorting algorithm---a first.
		\item A variety of useful heuristics exist to help a minimalist prover expose programmer intuition.
	\end{itemize}
\end{frame}

\begin{frame}{Future Directions}
	\begin{itemize}
		\item Better transformation fitness functions
		\item Other prover styles
		\item Evaulate usability of new features
		\item Increase type-system intuitiveness
		\item Prover scalability
	\end{itemize}
\end{frame}


\begin{frame}{Questions?}
~
\end{frame}

\end{document}
