

\section{Automated Proofs\label{apx:proofs}}
%----------------------------------------------------------------

This appendix contains a representative selection of the full automated proofs as generated by the minimalist prover.

%-----------------------------------------------------------------------------
	\subsection{Integer\_Template}	%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
		\subsubsection{Iterative\_Add\_to\_Realiz}	%-----------------------------------------------------------------------------

\begin{lstlisting}[language=resolve]
Proofs for Iterative_Add_to_Realiz generated Sun Apr 14 14:35:35 EDT 2013

=================================== Summary ===================================

	0_1	......... proved in 5837ms via 5 steps (0 search)
	0_2	......... proved in 3719ms via 5 steps (0 search)
	0_3	......... proved in 606ms via 10 steps (0 search)
	0_4	......... proved in 1036ms via 9 steps (0 search)
	0_5	......... proved in 4006ms via 6 steps (0 search)
	0_6	......... proved in 616ms via 8 steps (0 search)
	0_7	......... proved in 683ms via 5 steps (0 search)
	1_1	......... proved in 5385ms via 9 steps (0 search)

=================================== 0_1 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0)
  -->
((i + j) = (i + j))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Symmetric equality is true

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0)
  -->


Q.E.D.

=================================== 0_2 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0)
  -->
(j >= 0)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied (j >= 0)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0)
  -->


Q.E.D.

=================================== 0_3 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->
((?i + 1) <= max_int)

Applied not((i = j)) = (i /= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
(?j /= 0)
  -->
((?i + 1) <= max_int)

Applied ((i >= j) and (i /= j)) = (i > j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0)
  -->
((?i + 1) <= max_int)

--- Done Minimizing Antecedent ---

Applied ((?i + ?j) = (i + j))

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
((?i + ?j) <= max_int)
  -->
((?i + 1) <= max_int)

Applied ((i + j) <= k) and (j > 0) implies (i < k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
((?i + ?j) <= max_int) and
(?i < max_int)
  -->
((?i + 1) <= max_int)

--- Done Developing Antecedent ---

Applied ((i + 1) <= j) = (i < j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
((?i + ?j) <= max_int) and
(?i < max_int)
  -->
(?i < max_int)

--- Done Minimizing Consequent ---

Applied (?i < max_int)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
((?i + ?j) <= max_int) and
(?i < max_int)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
((?i + ?j) <= max_int) and
(?i < max_int)
  -->


Q.E.D.

=================================== 0_4 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->
(min_int <= (?j - 1))

Applied not((i = j)) = (i /= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
(?j /= 0)
  -->
(min_int <= (?j - 1))

Applied ((i >= j) and (i /= j)) = (i > j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0)
  -->
(min_int <= (?j - 1))

--- Done Minimizing Antecedent ---

Applied (i <= j) and (k > j) implies (i < k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
(min_int < ?j)
  -->
(min_int <= (?j - 1))

--- Done Developing Antecedent ---

Applied (i <= (j - 1)) = (i < j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
(min_int < ?j)
  -->
(min_int < ?j)

--- Done Minimizing Consequent ---

Applied (min_int < ?j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
(min_int < ?j)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0) and
(min_int < ?j)
  -->


Q.E.D.

=================================== 0_5 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->
(((?i + 1) + (?j - 1)) = (i + j))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied ((i + k) + (j - k)) = (i + j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->
((?i + ?j) = (i + j))

--- Done Minimizing Consequent ---

Applied ((?i + ?j) = (i + j))

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->


Q.E.D.

=================================== 0_6 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->
((?j - 1) >= 0)

Applied not((i = j)) = (i /= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
(?j /= 0)
  -->
((?j - 1) >= 0)

Applied ((i >= j) and (i /= j)) = (i > j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0)
  -->
((?j - 1) >= 0)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied ((i - 1) >= j) = (i > j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0)
  -->
(?j > 0)

--- Done Minimizing Consequent ---

Applied (?j > 0)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j > 0)
  -->


Q.E.D.

=================================== 0_7 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->
((?j - 1) < ?j)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied ((i - 1) < i)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
not((?j = 0))
  -->


Q.E.D.

=================================== 1_1 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + ?j) = (i + j)) and
(?j >= 0) and
(?j = 0)
  -->
(?i = (i + j))

Applied ?j = 0

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((?i + 0) = (i + j)) and
(?j >= 0) and
(?j = 0)
  -->
(?i = (i + j))

Applied (i + 0) = i

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
(?i = (i + j)) and
(?j >= 0) and
(?j = 0)
  -->
(?i = (i + j))

Applied ?i = (i + j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((i + j) = (i + j)) and
(?j >= 0) and
(?j = 0)
  -->
(?i = (i + j))

Applied ?i = (i + j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((i + j) = (i + j)) and
(?j >= 0) and
(?j = 0)
  -->
((i + j) = (i + j))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Symmetric equality is true

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((i + j) = (i + j)) and
(?j >= 0) and
(?j = 0)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(min_int <= j) and
(j <= max_int) and
(min_int <= i) and
(i <= max_int) and
(min_int <= (i + j)) and
((i + j) <= max_int) and
(j >= 0) and
((i + j) = (i + j)) and
(?j >= 0) and
(?j = 0)
  -->


Q.E.D.

\end{lstlisting}

%-----------------------------------------------------------------------------
	\subsection{Queue\_Template}	%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
		\subsubsection{Selection\_Sort\_Realiz}	%-----------------------------------------------------------------------------

\begin{lstlisting}[language=resolve]
Proofs for Selection_Sort_Realization generated Sun Apr 14 17:29:56 EDT 2013

=================================== Summary ===================================

	0_1	......... proved in 1758ms via 6 steps (0 search)
	0_2	......... proved in 470ms via 5 steps (0 search)
	0_3	......... proved in 878ms via 5 steps (0 search)
	0_4	......... proved in 1503ms via 6 steps (1 search)
	0_5	......... proved in 3008ms via 8 steps (0 search)
	0_6	......... proved in 3734ms via 9 steps (3 search)
	0_7	......... proved in 1920ms via 8 steps (0 search)
	0_8	......... proved in 1815ms via 10 steps (1 search)
	0_9	......... proved in 2398ms via 9 steps (3 search)
	1_1	......... proved in 552ms via 5 steps (0 search)
	1_2	......... proved in 1170ms via 10 steps (1 search)
	2_1	......... proved in 868ms via 5 steps (0 search)
	2_2	......... proved in 1995ms via 8 steps (0 search)
	2_3	......... proved in 1708ms via 5 steps (0 search)
	2_4	......... proved in 2052ms via 6 steps (1 search)
	2_5	......... proved in 3608ms via 14 steps (0 search)
	2_6	......... proved in 4559ms via 12 steps (3 search)
	2_7	......... proved in 1929ms via 10 steps (2 search)
	2_8	......... proved in 1978ms via 7 steps (0 search)
	3_1	......... proved in 921ms via 5 steps (0 search)
	3_2	......... proved in 1940ms via 8 steps (0 search)
	3_3	......... proved in 1750ms via 5 steps (0 search)
	3_4	......... proved in 1764ms via 6 steps (1 search)
	3_5	......... proved in 3356ms via 14 steps (0 search)
	3_6	......... proved in 4418ms via 10 steps (1 search)
	3_7	......... proved in 2226ms via 10 steps (2 search)
	3_8	......... proved in 2002ms via 7 steps (0 search)
	4_1	......... proved in 956ms via 5 steps (0 search)
	4_2	......... proved in 3150ms via 12 steps (0 search)
	4_3	......... proved in 1177ms via 5 steps (0 search)
	4_4	......... proved in 3455ms via 18 steps (3 search)

=================================== 0_1 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->
Is_Permutation((Q o Empty_String), Q)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied (S o Empty_String) = S

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->
Is_Permutation(Q, Q)

Applied Is_Permutation(S, S)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->


Q.E.D.

=================================== 0_2 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->
Is_Conformal_With(LEQV, Empty_String)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied Is_Conformal_With(f, Empty_String)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->


Q.E.D.

=================================== 0_3 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->
Is_Universally_Related(Empty_String, Q, LEQV)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied Is_Universally_Related(Empty_String, S, f)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length)
  -->


Q.E.D.

=================================== 0_4 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0)
  -->
(|??Q| /= 0)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to (i > 0)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0)
  -->
(|??Q| > 0)

Applied (|??Q| > 0)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0)
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0)
  -->


Q.E.D.

=================================== 0_5 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1))
  -->
(|?Sorted_Queue| < Max_Length)

--- Done Minimizing Antecedent ---

Applied Is_Permutation(S, T) implies (|S| = |T|)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
(|(??Q o ?Sorted_Queue)| = |Q|)
  -->
(|?Sorted_Queue| < Max_Length)

Applied (|(S o T)| = |U|) and (|S| > 0) implies (|T| < |U|)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
(|(??Q o ?Sorted_Queue)| = |Q|) and
(|?Sorted_Queue| < |Q|)
  -->
(|?Sorted_Queue| < Max_Length)

Applied (i < j) and (j <= k) implies (i < k)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
(|(??Q o ?Sorted_Queue)| = |Q|) and
(|?Sorted_Queue| < |Q|) and
(|?Sorted_Queue| < Max_Length)
  -->
(|?Sorted_Queue| < Max_Length)

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied (|?Sorted_Queue| < Max_Length)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
(|(??Q o ?Sorted_Queue)| = |Q|) and
(|?Sorted_Queue| < |Q|) and
(|?Sorted_Queue| < Max_Length)
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
(|(??Q o ?Sorted_Queue)| = |Q|) and
(|?Sorted_Queue| < |Q|) and
(|?Sorted_Queue| < Max_Length)
  -->


Q.E.D.

=================================== 0_6 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1))
  -->
Is_Permutation((?Q o (?Sorted_Queue o <?Lowest_Remaining>)), Q)

--- Done Minimizing Antecedent ---

Applied Is_Permutation(S, T) and Is_Permutation((T o U), V) implies Is_Permutation((S o U), V)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Permutation(((?Q o <?Lowest_Remaining>) o ?Sorted_Queue), Q)
  -->
Is_Permutation((?Q o (?Sorted_Queue o <?Lowest_Remaining>)), Q)

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied (U o (V o W)) = ((U o V) o W)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Permutation(((?Q o <?Lowest_Remaining>) o ?Sorted_Queue), Q)
  -->
Is_Permutation(((?Q o ?Sorted_Queue) o <?Lowest_Remaining>), Q)

Applied Is_Permutation(((S o U) o T), V) = Is_Permutation((S o (T o U)), V)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Permutation(((?Q o <?Lowest_Remaining>) o ?Sorted_Queue), Q)
  -->
Is_Permutation((?Q o (<?Lowest_Remaining> o ?Sorted_Queue)), Q)

Applied (U o (V o W)) = ((U o V) o W)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Permutation(((?Q o <?Lowest_Remaining>) o ?Sorted_Queue), Q)
  -->
Is_Permutation(((?Q o <?Lowest_Remaining>) o ?Sorted_Queue), Q)

Applied Is_Permutation(((?Q o <?Lowest_Remaining>) o ?Sorted_Queue), Q)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Permutation(((?Q o <?Lowest_Remaining>) o ?Sorted_Queue), Q)
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Permutation(((?Q o <?Lowest_Remaining>) o ?Sorted_Queue), Q)
  -->


Q.E.D.

=================================== 0_7 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1))
  -->
Is_Conformal_With(LEQV, (?Sorted_Queue o <?Lowest_Remaining>))

--- Done Minimizing Antecedent ---

Applied Is_Universally_Related(S, T, f) and Is_Permutation(U, T) implies Is_Universally_Related(S, U, f)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV)
  -->
Is_Conformal_With(LEQV, (?Sorted_Queue o <?Lowest_Remaining>))

Applied Is_Universally_Related(S, (T o U), f) implies (Is_Universally_Related(S, T, f) and Is_Universally_Related(S, U, f))

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV)
  -->
Is_Conformal_With(LEQV, (?Sorted_Queue o <?Lowest_Remaining>))

Applied Is_Conformal_With(f, S) and Is_Universally_Related(S, <e>, f) implies Is_Conformal_With(f, (S o <e>))

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV) and
Is_Conformal_With(LEQV, (?Sorted_Queue o <?Lowest_Remaining>))
  -->
Is_Conformal_With(LEQV, (?Sorted_Queue o <?Lowest_Remaining>))

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Is_Conformal_With(LEQV, (?Sorted_Queue o <?Lowest_Remaining>))

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV) and
Is_Conformal_With(LEQV, (?Sorted_Queue o <?Lowest_Remaining>))
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV) and
Is_Conformal_With(LEQV, (?Sorted_Queue o <?Lowest_Remaining>))
  -->


Q.E.D.

=================================== 0_8 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1))
  -->
Is_Universally_Related((?Sorted_Queue o <?Lowest_Remaining>), ?Q, LEQV)

--- Done Minimizing Antecedent ---

Applied Is_Universally_Related(S, T, f) and Is_Permutation(U, T) implies Is_Universally_Related(S, U, f)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV)
  -->
Is_Universally_Related((?Sorted_Queue o <?Lowest_Remaining>), ?Q, LEQV)

Applied Is_Universally_Related(S, (T o U), f) implies (Is_Universally_Related(S, T, f) and Is_Universally_Related(S, U, f))

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV)
  -->
Is_Universally_Related((?Sorted_Queue o <?Lowest_Remaining>), ?Q, LEQV)

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to Is_Universally_Related(S, U, f) and Is_Universally_Related(T, U, f)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV)
  -->
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV)

Applied Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV)
  -->
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV)
  -->
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV)

Applied Is_Universally_Related(?Sorted_Queue, ?Q, LEQV)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV)
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
Is_Universally_Related(?Sorted_Queue, (?Q o <?Lowest_Remaining>), LEQV) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
Is_Universally_Related(?Sorted_Queue, <?Lowest_Remaining>, LEQV)
  -->


Q.E.D.

=================================== 0_9 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1))
  -->
(|?Q| < |??Q|)

--- Done Minimizing Antecedent ---

Applied ((i = (j - k)) = ((i + k) = j))

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
((|?Q| + 1) = |??Q|)
  -->
(|?Q| < |??Q|)

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied |?Q| = (|??Q| - 1)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
((|?Q| + 1) = |??Q|)
  -->
((|??Q| - 1) < |??Q|)

Applied |??Q| = (|?Q| + 1)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
((|?Q| + 1) = |??Q|)
  -->
(((|?Q| + 1) - 1) < |??Q|)

Applied |??Q| = (|?Q| + 1)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
((|?Q| + 1) = |??Q|)
  -->
(((|?Q| + 1) - 1) < (|?Q| + 1))

Applied ((i - 1) < i)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
((|?Q| + 1) = |??Q|)
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((??Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ??Q, LEQV) and
(|??Q| > 0) and
Is_Permutation((?Q o <?Lowest_Remaining>), ??Q) and
Is_Universally_Related(<?Lowest_Remaining>, ?Q, LEQV) and
(|?Q| = (|??Q| - 1)) and
((|?Q| + 1) = |??Q|)
  -->


Q.E.D.

=================================== 1_1 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((?Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
not((|?Q| > 0))
  -->
Is_Conformal_With(LEQV, ?Sorted_Queue)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Is_Conformal_With(LEQV, ?Sorted_Queue)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((?Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
not((|?Q| > 0))
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((?Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
not((|?Q| > 0))
  -->


Q.E.D.

=================================== 1_2 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((?Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
not((|?Q| > 0))
  -->
Is_Permutation(Q, ?Sorted_Queue)

Applied not((n > 0)) = (n = 0)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((?Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
(|?Q| = 0)
  -->
Is_Permutation(Q, ?Sorted_Queue)

Applied (|S| = 0) = (S = Empty_String)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((?Q o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
(?Q = Empty_String)
  -->
Is_Permutation(Q, ?Sorted_Queue)

Applied ?Q = Empty_String

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation((Empty_String o ?Sorted_Queue), Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
(?Q = Empty_String)
  -->
Is_Permutation(Q, ?Sorted_Queue)

--- Done Minimizing Antecedent ---

Applied (Empty_String o S) = S

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation(?Sorted_Queue, Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
(?Q = Empty_String)
  -->
Is_Permutation(Q, ?Sorted_Queue)

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Is_Permutation(T, S) = Is_Permutation(S, T)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation(?Sorted_Queue, Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
(?Q = Empty_String)
  -->
Is_Permutation(?Sorted_Queue, Q)

Applied Is_Permutation(?Sorted_Queue, Q)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation(?Sorted_Queue, Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
(?Q = Empty_String)
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
(|Q| <= Max_Length) and
Is_Permutation(?Sorted_Queue, Q) and
Is_Conformal_With(LEQV, ?Sorted_Queue) and
Is_Universally_Related(?Sorted_Queue, ?Q, LEQV) and
(?Q = Empty_String)
  -->


Q.E.D.

=================================== 2_1 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0)
  -->
(|Q| /= 0)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied (|Q| /= 0)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0)
  -->
true

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0)
  -->


Q.E.D.

=================================== 2_2 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
(Q = (<??Min> o ???Q))
  -->
Is_Permutation(((Empty_String o ???Q) o <??Min>), Q)

Applied Q = (<??Min> o ???Q)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
((<??Min> o ???Q) = (<??Min> o ???Q))
  -->
Is_Permutation(((Empty_String o ???Q) o <??Min>), Q)

Applied Q = (<??Min> o ???Q)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
((<??Min> o ???Q) = (<??Min> o ???Q))
  -->
Is_Permutation(((Empty_String o ???Q) o <??Min>), (<??Min> o ???Q))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied (Empty_String o S) = S

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
((<??Min> o ???Q) = (<??Min> o ???Q))
  -->
Is_Permutation((???Q o <??Min>), (<??Min> o ???Q))

Applied Is_Permutation((S o T), (T o S))

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
((<??Min> o ???Q) = (<??Min> o ???Q))
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
((<??Min> o ???Q) = (<??Min> o ???Q))
  -->


Q.E.D.

=================================== 2_3 ===================================

[PROVED] via:

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
(Q = (<??Min> o ???Q))
  -->
Is_Universally_Related(<??Min>, Empty_String, LEQV)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied Is_Universally_Related(S, Empty_String, f)

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
(Q = (<??Min> o ???Q))
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(min_int <= 0) and
(0 < max_int) and
(Last_Char_Num > 0) and
(Max_Length > 0) and
(min_int <= Max_Length) and
(Max_Length <= max_int) and
Is_Total_Preordering(LEQV) and
Entry.is_initial(Min) and
(|Q| <= Max_Length) and
(|Q| /= 0) and
(Q = (<??Min> o ???Q))
  -->


Q.E.D.
\end{lstlisting}

The remaining VCs for selection sort are omitted for brevity.

%-----------------------------------------------------------------------------
	\subsection{Stack\_Template}	%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
		\subsubsection{Array\_Realiz}	%-----------------------------------------------------------------------------

\begin{lstlisting}[language=resolve]
Proofs for Array_Realiz generated Sun Apr 14 19:05:44 EDT 2013

=================================== Summary ===================================

	0_1	......... proved in 581ms via 5 steps (0 search)
	1_1	......... proved in 4325ms via 7 steps (0 search)
	2_1	......... proved in 171ms via 5 steps (0 search)
	2_2	......... proved in 4648ms via 7 steps (1 search)
	2_3	......... proved in 188ms via 6 steps (0 search)
	3_1	......... proved in 18903ms via 7 steps (2 search)
	3_2	......... proved in 2909ms via 8 steps (0 search)
	3_3	......... proved in 1621ms via 6 steps (1 search)
	3_4	......... proved in 1991ms via 8 steps (0 search)
	3_5	......... proved in 2661ms via 9 steps (2 search)
	4_1	......... proved in 6981ms via 11 steps (3 search)
	4_2	......... proved in 1306ms via 5 steps (0 search)
	4_3	......... proved in 1162ms via 9 steps (0 search)
	4_4	......... proved in 1343ms via 6 steps (1 search)
	4_5	......... proved in 1190ms via 7 steps (0 search)
	5_1	......... proved in 1944ms via 5 steps (0 search)
	5_2	......... proved in 2575ms via 5 steps (0 search)
	5_3	......... proved in 1648ms via 7 steps (0 search)
	5_4	......... proved in 1899ms via 5 steps (0 search)
	6_1	......... proved in 2079ms via 5 steps (0 search)
	6_2	......... proved in 2688ms via 5 steps (0 search)
	6_3	......... proved in 2290ms via 7 steps (0 search)
	6_4	......... proved in 1710ms via 5 steps (0 search)
	7_1	......... proved in 676ms via 5 steps (0 search)
	7_2	......... proved in 1584ms via 7 steps (0 search)
	7_3	......... proved in 538ms via 4 steps (0 search)
	7_4	......... proved in 837ms via 6 steps (0 search)

=================================== 0_1 ===================================

[PROVED] via:

(Lower_Bound <= Upper_Bound)
  -->
(Lower_Bound <= Upper_Bound)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied (Lower_Bound <= Upper_Bound)

(Lower_Bound <= Upper_Bound)
  -->
true

Applied Eliminate true conjunct

(Lower_Bound <= Upper_Bound)
  -->


Q.E.D.

=================================== 1_1 ===================================

[PROVED] via:

(Max_Depth > 0) and
(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth)
  -->
(|Reverse(Concatenate(S.Contents, S.Top))| <= Max_Depth)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied |Reverse(S)| = |S|

(Max_Depth > 0) and
(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth)
  -->
(|Concatenate(S.Contents, S.Top)| <= Max_Depth)

Applied |Concatenate(f, i)| = i

(Max_Depth > 0) and
(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth)
  -->
(S.Top <= Max_Depth)

--- Done Minimizing Consequent ---

Applied (S.Top <= Max_Depth)

(Max_Depth > 0) and
(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth)
  -->
true

Applied Eliminate true conjunct

(Max_Depth > 0) and
(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth)
  -->


Q.E.D.

=================================== 2_1 ===================================

[PROVED] via:

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0)
  -->
(0 <= 0)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied (i <= i)

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0)
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0)
  -->


Q.E.D.

=================================== 2_2 ===================================

[PROVED] via:

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0)
  -->
(0 <= Max_Depth)

--- Done Minimizing Antecedent ---

Applied ((i > j) = (j < i))

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0) and
(0 < Max_Depth)
  -->
(0 <= Max_Depth)

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to (i < j)

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0) and
(0 < Max_Depth)
  -->
(0 < Max_Depth)

Applied (0 < Max_Depth)

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0) and
(0 < Max_Depth)
  -->
true

Applied Eliminate true conjunct

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0) and
(0 < Max_Depth)
  -->


Q.E.D.

=================================== 2_3 ===================================

[PROVED] via:

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0) and
(Conc_S = Reverse(Concatenate(S.Contents, 0)))
  -->
(Reverse(Concatenate(S.Contents, 0)) = Empty_String)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied Concatenate(f, 0) = Empty_String

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0) and
(Conc_S = Reverse(Concatenate(S.Contents, 0)))
  -->
(Reverse(Empty_String) = Empty_String)

Applied (Reverse(Empty_String) = Empty_String)

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0) and
(Conc_S = Reverse(Concatenate(S.Contents, 0)))
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

Entry.Is_Initial(S.Contents(i)) and
(Max_Depth > 0) and
(Conc_S = Reverse(Concatenate(S.Contents, 0)))
  -->


Q.E.D.

=================================== 3_1 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth)
  -->
(1 <= (S.Top + 1))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied (i <= (j + k)) = ((i - k) <= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth)
  -->
((1 - 1) <= S.Top)

Applied (i - i) = 0

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth)
  -->
(0 <= S.Top)

Applied (0 <= S.Top)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth)
  -->


Q.E.D.

=================================== 3_2 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth)
  -->
((S.Top + 1) <= Max_Depth)

Applied |Reverse(S)| = |S|

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Concatenate(S.Contents, S.Top)| < Max_Depth)
  -->
((S.Top + 1) <= Max_Depth)

Applied |Concatenate(f, i)| = i

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(S.Top < Max_Depth)
  -->
((S.Top + 1) <= Max_Depth)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied ((i + 1) <= j) = (i < j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(S.Top < Max_Depth)
  -->
(S.Top < Max_Depth)

--- Done Minimizing Consequent ---

Applied (S.Top < Max_Depth)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(S.Top < Max_Depth)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(S.Top < Max_Depth)
  -->


Q.E.D.

=================================== 3_3 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
(0 <= (S.Top + 1))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to (i <= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
(0 <= S.Top)

Applied (0 <= S.Top)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->


Q.E.D.

=================================== 3_4 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
((S.Top + 1) <= Max_Depth)

Applied |Reverse(S)| = |S|

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Concatenate(S.Contents, S.Top)| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
((S.Top + 1) <= Max_Depth)

Applied |Concatenate(f, i)| = i

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(S.Top < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
((S.Top + 1) <= Max_Depth)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied ((i + 1) <= j) = (i < j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(S.Top < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
(S.Top < Max_Depth)

--- Done Minimizing Consequent ---

Applied (S.Top < Max_Depth)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(S.Top < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(S.Top < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->


Q.E.D.

=================================== 3_5 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
(Reverse(Concatenate(lambda (j : Z).{E(j = (S.Top + 1)); S.Contents(j), otherwise}, (S.Top + 1))) = (<E> o Reverse(Concatenate(S.Contents, S.Top))))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied Concatenate(lambda (j : Z).{e(j = i); f(j), otherwise}, i) = (Concatenate(f, (i - 1)) o <e>)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
(Reverse((Concatenate(S.Contents, ((S.Top + 1) - 1)) o <E>)) = (<E> o Reverse(Concatenate(S.Contents, S.Top))))

Applied ((i + j) - j) = i

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
(Reverse((Concatenate(S.Contents, S.Top) o <E>)) = (<E> o Reverse(Concatenate(S.Contents, S.Top))))

--- Done Minimizing Consequent ---

Applied Reverse((U o V)) = (Reverse(V) o Reverse(U))

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
((Reverse(<E>) o Reverse(Concatenate(S.Contents, S.Top))) = (<E> o Reverse(Concatenate(S.Contents, S.Top))))

Applied Reverse(<E>) = <E>

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
((<E> o Reverse(Concatenate(S.Contents, S.Top))) = (<E> o Reverse(Concatenate(S.Contents, S.Top))))

Applied Symmetric equality is true

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
(|Reverse(Concatenate(S.Contents, S.Top))| < Max_Depth) and
(?E = S.Contents((S.Top + 1)))
  -->


Q.E.D.

=================================== 4_1 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(|Reverse(Concatenate(S.Contents, S.Top))| /= 0)
  -->
(1 <= S.Top)

Applied |Reverse(S)| = |S|

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(|Concatenate(S.Contents, S.Top)| /= 0)
  -->
(1 <= S.Top)

Applied |Concatenate(f, i)| = i

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(0 <= S.Top) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(S.Top /= 0)
  -->
(1 <= S.Top)

Applied ((i <= j) and (j /= i)) = (i < j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(0 < S.Top)
  -->
(1 <= S.Top)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied (i <= j) = ((i - 1) <= (j - 1))

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(0 < S.Top)
  -->
((1 - 1) <= (S.Top - 1))

Applied (i - i) = 0

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(0 < S.Top)
  -->
(0 <= (S.Top - 1))

Applied (i <= (j - 1)) = (i < j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(0 < S.Top)
  -->
(0 < S.Top)

Applied (0 < S.Top)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(0 < S.Top)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(1 <= Max_Depth) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(min_int <= 1) and
(1 <= max_int) and
(Max_Depth > 0) and
(min_int <= Max_Depth) and
(Max_Depth <= max_int) and
(S.Top <= Max_Depth) and
(Conc_S = Reverse(Concatenate(S.Contents, S.Top))) and
Entry.is_initial(R) and
(0 < S.Top)
  -->


Q.E.D.
\end{lstlisting}

The remaining VCs of the array realization are omitted for brevity.

%-----------------------------------------------------------------------------
	\subsection{Static\_Array\_Template}	%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
		\subsubsection{Binary\_Search\_Realiz}	%-----------------------------------------------------------------------------

\begin{lstlisting}[language=resolve]
Proofs for Bin_Search_Realiz generated Mon Apr 22 23:30:34 EDT 2013

=================================== Summary ===================================

	0_1	......... proved in 1534ms via 6 steps (1 search)
	0_2	......... proved in 693ms via 5 steps (0 search)
	0_3	......... proved in 497ms via 5 steps (0 search)
	1_1	......... proved in 2565ms via 8 steps (0 search)
	1_2	......... proved in 1495ms via 5 steps (0 search)
	1_3	......... proved in 1189ms via 5 steps (0 search)
	1_4	......... proved in 556ms via 5 steps (0 search)
	1_5	......... proved in 6257ms via 10 steps (3 search)
	1_6	......... proved in 2523ms via 9 steps (1 search)
	1_7	......... proved in 6497ms via 10 steps (3 search)
	1_8	......... proved in 2087ms via 9 steps (1 search)
	1_9	......... [SKIPPED] after 20007ms
	1_10	......... proved in 1801ms via 7 steps (1 search)
	1_11	......... proved in 2049ms via 5 steps (0 search)
	1_12	......... [SKIPPED] after 2023ms
	1_13	......... proved in 3769ms via 9 steps (3 search)
	2_1	......... proved in 1456ms via 8 steps (0 search)
	2_2	......... proved in 1071ms via 5 steps (0 search)
	2_3	......... proved in 900ms via 5 steps (0 search)
	2_4	......... proved in 490ms via 5 steps (0 search)
	2_5	......... proved in 7308ms via 10 steps (3 search)
	2_6	......... proved in 3480ms via 9 steps (1 search)
	2_7	......... proved in 7758ms via 10 steps (3 search)
	2_8	......... proved in 2604ms via 9 steps (1 search)
	2_9	......... [SKIPPED] after 20135ms
	2_10	......... proved in 2615ms via 11 steps (4 search)
	2_11	......... proved in 1856ms via 5 steps (0 search)
	2_12	......... [SKIPPED] after 1575ms
	2_13	......... proved in 10870ms via 8 steps (3 search)
	3_1	......... proved in 1517ms via 8 steps (0 search)
	3_2	......... proved in 1087ms via 5 steps (0 search)
	3_3	......... proved in 1021ms via 5 steps (0 search)
	3_4	......... proved in 430ms via 5 steps (0 search)
	3_5	......... proved in 5642ms via 10 steps (3 search)
	3_6	......... proved in 2101ms via 9 steps (1 search)
	3_7	......... proved in 5860ms via 10 steps (3 search)
	3_8	......... proved in 2687ms via 9 steps (1 search)
	3_9	......... [SKIPPED] after 20015ms
	3_10	......... proved in 1844ms via 5 steps (0 search)
	3_11	......... proved in 2308ms via 10 steps (2 search)
	3_12	......... [SKIPPED] after 2203ms
	3_13	......... proved in 18560ms via 9 steps (2 search)
	4_1	......... proved in 1748ms via 9 steps (3 search)
	4_2	......... proved in 567ms via 5 steps (0 search)
	4_3	......... proved in 620ms via 5 steps (0 search)

=================================== 0_1 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->
((LEQ(x, y) and LEQ(y, x)) = (x = y))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to Is_Antisymmetric(f)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->
Is_Antisymmetric(LEQ)

Applied Is_Antisymmetric(LEQ)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->


Q.E.D.

=================================== 0_2 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->
(x = x)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Symmetric equality is true

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->


Q.E.D.

=================================== 0_3 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->
(y = y)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Symmetric equality is true

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Total_Preordering(LEQ) and
Is_Antisymmetric(LEQ)
  -->


Q.E.D.

=================================== 1_1 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(false = (Exists_Between(key, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (Lower_Bound - 1)) or Exists_Between(key, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (Upper_Bound + 1), Upper_Bound)))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied Exists_Between(e, S, i, (i - 1)) = false

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(false = (false or Exists_Between(key, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (Upper_Bound + 1), Upper_Bound)))

Applied Exists_Between(e, S, (i + 1), i) = false

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(false = (false or false))

Applied (false or false) = false

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(false = false)

--- Done Minimizing Consequent ---

Applied Symmetric equality is true

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->


Q.E.D.

=================================== 1_2 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(Lower_Bound <= Lower_Bound)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied (i <= i)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->


Q.E.D.

=================================== 1_3 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(Upper_Bound <= Upper_Bound)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied (i <= i)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->


Q.E.D.

=================================== 1_4 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(A = A)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Symmetric equality is true

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->


Q.E.D.

=================================== 1_5 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->
(Lower_Bound <= (?low + ((?high - ?low) / 2)))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to (i <= j) and (0 <= k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->
(Lower_Bound <= ?low) and
(0 <= ((?high - ?low) / 2))

Applied (Lower_Bound <= ?low)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->
true and
(0 <= ((?high - ?low) / 2))

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->
(0 <= ((?high - ?low) / 2))

Applied Strengthen to (0 <= i)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->
(0 <= (?high - ?low))

Applied (0 <= (j - i)) = (i <= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->
(?low <= ?high)

Applied (?low <= ?high)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->


Q.E.D.

=================================== 1_6 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high)
  -->
((?low + ((?high - ?low) / 2)) <= Upper_Bound)

--- Done Minimizing Antecedent ---

Applied (i <= j) and (j <= k) implies (i <= k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?low <= Upper_Bound)
  -->
((?low + ((?high - ?low) / 2)) <= Upper_Bound)

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to (i <= k) and (j <= k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?low <= Upper_Bound)
  -->
(?low <= Upper_Bound) and
(?high <= Upper_Bound)

Applied (?low <= Upper_Bound)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?low <= Upper_Bound)
  -->
true and
(?high <= Upper_Bound)

Applied (?high <= Upper_Bound)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?low <= Upper_Bound)
  -->
true and
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?low <= Upper_Bound)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?low <= Upper_Bound)
  -->


Q.E.D.

=================================== 1_7 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->
(Lower_Bound <= (?low + ((?high - ?low) / 2)))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to (i <= j) and (0 <= k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->
(Lower_Bound <= ?low) and
(0 <= ((?high - ?low) / 2))

Applied (Lower_Bound <= ?low)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->
true and
(0 <= ((?high - ?low) / 2))

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->
(0 <= ((?high - ?low) / 2))

Applied Strengthen to (0 <= i)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->
(0 <= (?high - ?low))

Applied (0 <= (j - i)) = (i <= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->
(?low <= ?high)

Applied (?low <= ?high)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->


Q.E.D.

=================================== 1_8 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key)
  -->
((?low + ((?high - ?low) / 2)) <= Upper_Bound)

--- Done Minimizing Antecedent ---

Applied (i <= j) and (j <= k) implies (i <= k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?low <= Upper_Bound)
  -->
((?low + ((?high - ?low) / 2)) <= Upper_Bound)

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to (i <= k) and (j <= k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?low <= Upper_Bound)
  -->
(?low <= Upper_Bound) and
(?high <= Upper_Bound)

Applied (?low <= Upper_Bound)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?low <= Upper_Bound)
  -->
true and
(?high <= Upper_Bound)

Applied (?high <= Upper_Bound)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?low <= Upper_Bound)
  -->
true and
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?low <= Upper_Bound)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?low <= Upper_Bound)
  -->


Q.E.D.

=================================== 1_9 ===================================

[NOT PROVED]

=================================== 1_10 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
(Lower_Bound <= (?high + 1))

--- Done Minimizing Antecedent ---

Applied (i <= j) and (j <= k) implies (i <= k)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2)))) and
(Lower_Bound <= ?high)
  -->
(Lower_Bound <= (?high + 1))

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied Strengthen to (i <= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2)))) and
(Lower_Bound <= ?high)
  -->
(Lower_Bound <= ?high)

Applied (Lower_Bound <= ?high)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2)))) and
(Lower_Bound <= ?high)
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2)))) and
(Lower_Bound <= ?high)
  -->


Q.E.D.

=================================== 1_11 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
(?high <= Upper_Bound)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

--- Done Minimizing Consequent ---

Applied (?high <= Upper_Bound)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->


Q.E.D.

=================================== 1_12 ===================================

[NOT PROVED]

=================================== 1_13 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
((?high - (?high + 1)) < (?high - ?low))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied (i - (i + j)) = -(j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
(-(1) < (?high - ?low))

--- Done Minimizing Consequent ---

Applied (i < j) = ((i + 1) <= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
((-(1) + 1) <= (?high - ?low))

Applied (-(i) + i) = 0

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
(0 <= (?high - ?low))

Applied (0 <= (j - i)) = (i <= j)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
(?low <= ?high)

Applied (?low <= ?high)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound))) and
(?result = (Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (?low - 1)) or Exists_Between(key, Concatenate(Shift(??A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (?high + 1), Upper_Bound))) and
(Lower_Bound <= ?low) and
(?high <= Upper_Bound) and
(??A = A) and
(?low <= ?high) and
(?A = lambda (j : Z).{??midVal(j = (?low + ((?high - ?low) / 2))); ??A(j), otherwise}) and
(??A((?low + ((?high - ?low) / 2))) = key) and
(?midVal = ?A((?low + ((?high - ?low) / 2))))
  -->


Q.E.D.

=================================== 2_1 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(false = (Exists_Between(key, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), Lower_Bound, (Lower_Bound - 1)) or Exists_Between(key, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (Upper_Bound + 1), Upper_Bound)))

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied Exists_Between(e, S, i, (i - 1)) = false

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(false = (false or Exists_Between(key, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)), (Upper_Bound + 1), Upper_Bound)))

Applied Exists_Between(e, S, (i + 1), i) = false

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(false = (false or false))

Applied (false or false) = false

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(false = false)

--- Done Minimizing Consequent ---

Applied Symmetric equality is true

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
true

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->


Q.E.D.

=================================== 2_2 ===================================

[PROVED] via:

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
(Lower_Bound <= Lower_Bound)

--- Done Minimizing Antecedent ---

--- Done Developing Antecedent ---

Applied (i <= i)

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->
true

--- Done Minimizing Consequent ---

Applied Eliminate true conjunct

(Last_Char_Num > 0) and
(min_int <= 0) and
(0 < max_int) and
(Lower_Bound <= Upper_Bound) and
(min_int <= Upper_Bound) and
(Upper_Bound <= max_int) and
(min_int <= Lower_Bound) and
(Lower_Bound <= max_int) and
Is_Conformal_With(LEQ, Concatenate(Shift(A, ((Lower_Bound - 1) * -(1))), (Upper_Bound - Lower_Bound)))
  -->


Q.E.D.
\end{lstlisting}

The remaining VCs of binary search are omitted for brevity.
