%----------------------------------------------------------------------------
\chapter{Verification Background and Related Work}\label{sec:background}
%----------------------------------------------------------------------------

In order to justify the presented research as well as place it in context, it is important to consider the full breadth of existing mathematical systems, provers, and verification libraries.  In this chapter, we discuss related work and necessary background in these areas.

%----------------------------------------------------------------------------
\section{Specification and Mathematical Systems}\label{sec:overviewSpec}
%----------------------------------------------------------------------------
Early systems for program specification include Z\cite{dillerZ} and Larch\cite{guttagLarch}.  Both are first-order predicate logics not grounded in any particular programming system, though each has been adapted for many different programming langauges.  Larch provides a two-tiered specification style to ease adapting it to a new language.  Because it is based on Zermelo-Fraenkel set theory, Z is one-sorted (i.e., it has only one ``type'': the \emph{set}).  Larch, on the other hand, is multi-sorted, but assumes all sorts are disjoint (i.e., it does not permit sub-``types'', among numerous other ``type'' relationships.)  These restrictions complicate the mapping of programming concepts in modern languages to their mathematical universes.  Modern systems for specification in practical systems often address the limitations on sorts, but, as we will see, many are restricted to first-order logics, severely restricting the genericity (and thus the reusability) of mathematical theories and specifications, as discussed in detail in Section \ref{sec:higherOrderDefinitions}.

A straightforward method of specification in practical systems is to permit them to be written programmatically in the target language--i.e., the specification is \emph{executable}.  This technique was introduced by the Eiffel language\cite{eiffel} in 1985 and served as the progenitor of modern contract-based programming\footnote{Indeed, the phrase ``Design by Contract'' remains a registered trademark of Eiffel Software.}.

An exectuable specification has the immediate advantage of permitting dynamic checks to be compiled into the code if static verification is not possible.  However, it raises a number of disturbing possibilities including specifications that have side effects or that require proofs of ``termination''.  Additionally, such a specification can introduce so-called ``implementation bias'' in which the implementer chooses an implementation that matches the specification closely rather than the best implementation.  A final complications is that the specification is only as clear as our understanding of the meaning of the underlying language.  If the language in question does not have a formal semantic, we're not any better off.

A number of specification systems use this method as their basis (though in some cases they offer non-executable extensions).  Eiffel, for example, persists as an important language to this day.  Another prominent example is the Java Modeling Language (JML)\cite{leavensJML}.  The majority of functions used in a JML specification are, in actuality, Java methods.  However, in order to defeat the side-effecting problem, they are required to be declared \emph{pure}, i.e., they must be demonstrably side-effect free (this does not, however, speak to their termination.)  ``Model methods'' may also be provided, which define a method for the purposes of specification, but contain no code---however, while JML provides some features for non-code-based specification, model methods are often still expressed in terms of (non-executable) Java code (i.e., in the formal comment there is commented-out Java code expressing the behavior of the model method.)  The logic of JML is first-order (i.e., we cannot quantify over methods or types), but we are able to take advantage of the flexibility of including ``code'' in our mathematical specification to achieve higher-order methods for the purpose of, for example, passing them as a parameter\footnote{We can effectively include an instance of the \emph{Strategy} design pattern in our specification.}.

Because of the tight integration between ``specification'' and ``code'' in JML, the mathematical realm becomes restricted to ideas expressible in Java.  E.g., the only type-relationship are Java type-relationships.  While this simplifies the mathematical realm and makes it consistent with the programmer's understanding, we posit that the necessary complexity of mathematical development required for true mathematical modularity necessitates a mathematical specialist.  Thus, the mathematical realm should target the universe familiar to such a specialist, rather than cater to a programmer.  Many restrictions necessitated by the computability requirements of code are irrelevant in the mathematical sphere and lead to specifications that are less general or less descriptive.

Another system with executable specifications is Why\cite{bobotWhy}.  Why is ML-like and focussed on reasoning about built-in structures like arrays rather than general data abstractions.  By using a variety of translation front-ends, Why can be an intermediate specification and programming representation for different programming languages including Java, C, and ML\cite{something}.

JML and Why are not alone in using this specification style: additional systems in this style include the specification language of Spec\#\cite{specsharp}, built on C\#, and ACL2\cite{kaufmannACL2}, built on a dialect of Common Lisp.

Another popular style of specification in practical systems relies heavily on separation logic\cite{reynoldsSeparationLogic}.  Because it models the heap directly, separation logic provides mechanisms for reasoning directly about aliasing and pointer arithmetic.  In order to bring these complex problems into the range of modern theorem provers, separation logic allows operations to explicitly state which areas of the heap they will modify, along with which arbitrary properties they expect the heap to maintain while they operate.  This requires the heap to be modeled in its entirety, along with specialized logical systems for reasoning about this model.  A notable system focussed on this style is Verifast\cite{jacobsVerifast}, a system for verifying Java and C programs.  It uses separation logic expressed in a custom specification language and targets the Z3 prover\cite{something}.

A third style of specification in practical systems is to use a strictly separate mathematical language for specification.  Such systems often provide more generality than others, since the mathematical language can usually be arbitrarily extended to permit new bases for mathematical models and provide generalized machinery for reasoning about these new classes of mathematical objects.  Examples of this kind of system are Jahob, the RESOLVE system developed here at Clemson, and the RESOLVE system being developed at The Ohio State University.  As explored in Section~\ref{sec:exPractical}, Jahob uses Isabelle as its specification language, granting it higher-order logic and a rich theory of sorts for free.  However, the usefulness of these features is hamstrung somewhat by a lack of support for the associated programmatic features in Java, such as generics and inheritence.  RESOLVE strives to provide a sorted, higher-order mathematical language, through the complete design and implementation of such a language as detailed in this dissertation.  OSU's RESOLVE implementation does make a clear delineation between mathematics and programming, and permits higher-order definitions, but does not permit the mathematical universe to be extended at this time.  As a result, its reasoning is limited to a small library of built-in sorts.

An interesting comparison of some additional practical systems with respect to their specification and reasoning systems can be found in \cite{bisl}.

Amongst the pure systems, the style of specification and mathematical representation becomes more uniform, at least in their almost-universal inclusion of the features crucial for a component specification platform, including higher-order definitions, first-class types, and a rich, extensible theory of sorts.  By far the most popular pure systems are Coq, described in detail in Section \ref{sec:exPure}, and Isabelle.

Isabelle is notable for providing a very small logical core from which all other theories and logics are built, permitting the system to be soundly extended with diverse logics for which it was not designed.  For example, the most popular variant, Isabelle/HOL, Isabelle with Higher Order Logic, provides multi-sorted higher-order logic, expressed in a reasonably intuitive mathematical syntax called Isar\cite{wenzelIsar}.

%----------------------------------------------------------------------------
\section{Automated Theorem Provers}\label{sec:overviewProvers}
%----------------------------------------------------------------------------
We may broadly partition automated theorem provers into three categories---those based on decision procedures, those based on boolean satisfiability (SAT)\footnote{Technically, SAT is a decision problem with finite solution space, and thus its solvers are decision procedures.  However, since this problem is NP-hard, we use ``decision procedure'' throughout to mean an algorithm that is \emph{efficiently decidable}.}, and those based on term rewriting.  The distinction between these is not clear-cut, however, as many (indeed, most) systems combine all three to some extent, using term rewriting as a preprocessing step before passing the problem off to a SAT-solver or a decision procedure, or using a feedback loop between a term-rewrite prover and a SAT-solver.

\subsection{Decision Procedures} The decision procedures are the least flexible but often the most efficient.  They take advantage of information about a specific domain to arrive at conclusions quickly.  Examples include linear arithmetic solvers of the kind found in Z3\cite{deMouraZ3} and OSU's SplitDecision\cite{Sit11} system for reasoning about finite sequences.  Because they exploit domain-specific information, these systems are necessarily hard-coded and cannot be generalized to new domains.

\subsection{SAT-Solvers} Provers in this class attempt to find valuations of boolean variables to satisfy a given formula.  While in general this is NP-hard, a number of branch-and-bound techniques can be used to drastically reduce the problem space for practical formulae.  Almost universally such provers use the Davis-Putnam-Logemann-Loveland (DPLL) algorithm, which is a constellation of specific heuristics and refinements that reduce the search space considerably in many cases.  For a good overview of this algorithm along with some recent refinements, the interested reader is directed to \cite{nieuwenhuisDPLL}.

A number of SAT-solvers exist.  Yices\cite{yices} and Z3 are popular provers based at their core on SAT-solvers.  It may seem difficult, at first, to apply provers for boolean formulae to complex programmatic proof obligations, but many techniques exist for translating complex domains into equisatisfiable boolean representations.  Indeed, because of the blazing speed and mature implementations of SAT, such translations are an active area of research (see, for example, \cite{ganeshArrayDecision} and \cite{sheiniIntegerDecision}.)  SAT-solvers extended to include the Maximum Satisfiability (Max-SAT) problem are able to provide useful debugging information in the form of counter-examples: indicating precise valuations under which a theorem does not hold.  Yices is an example of a SAT-solver with this capability.  The general applicability of boolean logic (particularly in the field of computing) makes SAT-solvers significantly more general, since they may be applied to any theory for which a translation into boolean logic exists.

\subsection{Term-Rewrite Provers}  These provers are the most flexible, but also the most difficult to optimize.  They are by far the most similar to how a human would proceed with a proof---by matching theorems against a set of known facts and goals, transforming them until we derive the result we want.  This general pattern-matching approach means that they can be applied to any domain about which a set of theorems has been established.  An excellent example of this kind of prover being used in a practical-style system is the prover used in the ACL2 system.  It utilizes a complex series of hints, provided by the person developing the theory, about which theorems should be applied in which way, then applying them sequentially.  This differs from the approach of our minimalist prover---where we eschew encoding information about how the prover should apply theorems, as we would prefer mathematicians reason about mathematics rather than about how a particular prover will apply it.  Additionally, while our rewrite-prover strives to operate over our distinct mathematical subsystem, ACL2's mathematics are much more tightly bound with its underlying language, Lisp.  A noteable feature of the ACL2 prover is its ability to automatically discover inductive proofs over certain restricted domains.

Many SAT-solver-based provers, including Yices and Z3, employ term-rewriting as a preprocessing step to simplify formulae or translate them into a heuristically-convenient form.

%----------------------------------------------------------------------------
\section{Benchmarks and Specification Engineering}\label{sec:overviewEngineering}
%----------------------------------------------------------------------------
A number of verification benchmarks and libraries exist, and at least one verification effort has tangentally acknowledged the specification engineering question.

The Jahob team has made a concerted effort to verify a number of data structures in a form as close as possible to how they appear in the Java standard library.  In a recent paper \cite{zee:annotations}, they discussed a subset of these which were linked data-structures, including \texttt{ArrayList}, \texttt{HashMap}, and \texttt{PriorityQueue}.  While small (on the order of ten components), this library represents the sort of effort we would like to make here---a library of components geared toward an exploration of a specific facet of verification.  The Jahob library is geared towards linked data structures and aims to maintain the component from modern industrial systems.  

A recent paper\cite{bouillaguetJahobFirstOrder} deals directly with specification engineering, noting that quantifiers consistently complicate verification.  It attempts to engineer the specifications of a set of data structures without quantifiers.  This enables the specifications to be translated down to a first-order logic, then passed to an efficient first-order prover.  This result, however, focusses on the translation process rather than the importance of specification style.  To our knowledge, the team has not embarked on a systematic exploration of this facet of verification.

Since 2010, the Verified Software: Tools, Theories, and Experiments conference has run a verified software competition.  Attendees are permitted to enter and are given a short amount of time to complete a handful of challenges.  Afterwards, the various solutoins are made public along with discussion by their implementers.

These challenges have explored varied domains, ranging from averaging an integer array to implementing a binary tree data structure.  The intent has been to get verification projects communicating and sharing ideas rather than to compare different styles of specification.  

This competition has revealed some interesting realities about modern verification systems \emph{vis-\'{a}-vis} modularity.  For example, in 2010, despite the fact that an earlier challenge required teams to create a list data structure, no team used that data structure in a subsequent challenge to implement an amortized queue with a linked list.  They instead re-implemented a different linked list for subsequent challenge problem solutions, presumably because queues required different properties to achieve verification or the original implementation of linked lists was unable to take advantage of the necessary modular verification mechanisms.

In 2008, researchers here at Clemson and at the Ohio State University compiled and published\cite{Benchmarks} a set of incremental benchmarks intended to be representative of the breadth of verification complexity, starting with simple integer addition and spanning system I/O, design patterns such as Iterator, and finally an integrated application.  The focus of these benchmarks was on demonstrating the capabilities considered essential to any verification system that was to be useful in practice.  At a subsequent VSTTE conference, the Microsoft verification team published their solutions to some of these benchmarks as implemented in Dafny\cite{DafnySolutions}, which revealed a number of interesting properties of that system.  This research contains our own implementation of some of these benchmarks.
