\chapter*{Abstract}
At the heart of the argument for formal, mathematical methods of software quality assurance is that increased energy spent to develop formal specifications and prove software components against those specifications is amortized over the lifetime of the verified component.  Thus, modularity and reuse are central prerequisites of practical verification.  Because of this, there are two strategies for reducing effective energy invested in a verified component: 1) decrease the amount of effort required to verify it, and 2) increase its reusability and thus its lifetime.

While many modern verification systems exist, few seem to have been designed with modularity and reuse in mind.  On the one hand are systems built on industrial, object-oriented languages, which provide modularity in the programming world, but whose specifications rely on mathematics that do not support these goals.  On the other hand are extensible, generic mathematical systems that are not integrated with programming languages that support component reuse.  The result, on both sides, is the creation of components insufficiently generic and extensible to be reused.

As we wish to verify components of increasing complexity, we must build these components out of smaller subcomponents.  If these subcomponents display poor modularity, they will compose poorly or not at all, resulting in complex interactions and proof obligations that are difficult to satisfy.  To date, modern systems have addressed this complexity by placing the onus of verification on a suite of sophisticated, industrial-strength automated theorem provers that are on the bleeding edge of artificial intelligence design.

This seems paradoxical, however, as programmers do not often rely on deep mathematical results when they reason about the correctness of components.  We posit that by shifting the burden to the design of good components and specifications, as supported by a flexible mathematical and specification subsystem, proof obligations should become much more obvious and more easily-proved.  In addition to influencing the design of our own system, RESOLVE, such exploration would benefit other systems as well, by informing specification and theory design across the board.

This thesis makes three primary contributions.  First, it develops a flexible mathematical framework for program specification designed with modularity and reuse in mind.  Second, presents the design and implementation of a minimalist prover sufficiently flexible to operate on that mathematical framework and determine the actual practical requirements for program verification of well-specified components.  Third, it combines components specified in the mathematical framework with the minimalist verifier to provide evidence in favor of our hypothesis: that well-engineered software should be straightforward to verify.
